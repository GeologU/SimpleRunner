### Несколько общих слов

Существенное время в моей работе я занимался инфраструктурными задачами в IT компаниях.
Если точнее, запуск неких задач и контроль их выполнения.

Этот проект демонстрирует несколько простых идей, которые могут сделать вашу работу нагляднее
и как следствие позволить завершить её с меньшим числом багов и большим удовольствием от работы.

Идеи таковы:
 - записывать для чего вам этот кусок кода, т.к. с накоплением числа функциональных блоков вы будете забывать о самом существовании некоторых из них;
 - для связанных задач в явном виде записывать их связи, т.к. это упрощает поддержку и позволяет строить более сложные схемы.

Код написан в таком виде чтобы избежать лишних зависимостей и сложного окружения.
Я осведомлён о существовании [GNU Make](http://www.gnu.org/software/make/), [Celery](http://www.celeryproject.org/) и других подобных продуктов (отдельный привет [REM](https://github.com/heni/rem) :wink:).

### bashrc

Часть моего `~/.bashrc`, возможно будет полезной кому-то ещё.
Дополняет PS1 (строку приглашения [Bash](http://www.gnu.org/software/bash/manual/bashref.html)):
 - показывает имя пользователя: root отображает красным, остальные зелёным (по аналогии могут быть отмечены цветом другие служебные пользователи, при необходимости);
 - показывает рабочий каталог;
 - показывает имя машины, что удобно при работе с несколькими серверами;
 - показывает строчку `user@host:/path`, чтобы можно было её сразу скопировать в аргументы команд вроде `scp`;
 - показывает время вывода строки приглашения, чтобы можно было судить о времени запуска и окончания работы команд;
 - показывает результат работы предыдущей команды с указанием имени сигнала, прервавшего программу;
 - подсвечивает результат успешной команды зелёным, неуспешной красным цветом.

```bash
* $?=0 | 2017-09-06 17:43:53 | alex@r5h:/home/alex *
$ true

* $?=0 | 2017-09-06 17:43:57 | alex@r5h:/home/alex *
$ false

* $?=1 | 2017-09-06 17:44:00 | alex@r5h:/home/alex *
$

* $?=0 | 2017-09-06 17:46:02 | alex@r5h:/home/alex *
$ sleep 20
Завершено

* $?=SIGTERM | 2017-09-06 17:46:38 | alex@r5h:/home/alex *
$

```

### skeleton.sh

#### Запуск

С помощью строки в начале файла `set -e -o pipefail` мы экономим очень, очень много времени и душевного здоровья.
`set -e` приводит к тому, что выполнение завершается с ошибкой при ошибке в любой простой команде, например `ls` на отсутствующий файл где-то в середине скрипта.
`set -o pipefail` приводит к ошибке в команде с конвейером, если хотя бы одна команда из конвейера дала ошибку.
Другими словами, эти настройки позволяют видеть ошибки.

С помощью вставки в конце скрипта
```bash
if [ -z "$1" ] || [ "$1" == "--help" ]; then
    usage
else
    "$@"
fi
```
мы получаем возможность вызывать любую функцию по имени, аргументы командной строки будут переданы в аргументы функции
```bash
$ ./skeleton.sh greetings Mark "ta, 6ta" Ann
Hello, Mark!
Hello, ta, 6ta!
Hello, Ann!
```
Соответственно много команд (больших и не очень) мы можем сложить в один файл, чтобы не искать нужное по многим файлам.

#### Help

Удобно иметь строчку с описанием команды.
```bash
$ ./skeleton.sh usage
greetings            say Hello to arguments
make                 echo Make
my                   echo my
day                  echo day
make_my_day          run in parallel: make, my, day
```

Для этого каждая функция должна уметь обработать аргумент `--help`.

Пример отсутствия описания:
```bash
$ cat skeleton.sh
...
no_help_example() {
    [ "$1" == "--help" ] && return 0 || true
...
```
Обратите внимание, что такая функция не будет отображена в выводе `$ skeleton.sh usage` совсем.

Пример рекомендуемого (одна простая строчка) описания:
```bash
$ cat skeleton.sh
...
greetings() {
    [ "$1" == "--help" ] && _help_and_exit "say Hello to arguments" || true
...
```

Но никаких ограничений на вывод функции по аргументу `--help` нет, и вы можете делать более сложные вещи:
```bash
$ cat skeleton.sh
...
print_functions() {
    if [ "$1" == "--help" ]; then
        echo
        _help_and_exit "print all functions names"
    fi
...
```

Описание команды формируется как строка чтобы можно было подставлять в неё значение переменных:
```bash
$ cat skeleton.sh
...
usage() {
        [ "$1" == "--help" ] && _help_and_exit "[or $(basename "$SELFNAME") --help] show this help message and exit"  || true
...
$ ./skeleton.sh 
...
usage                [or skeleton.sh --help] show this help message and exit
$
```

#### Граф зависимостей

Когда команды зависят друг от друга, удобна возможность посмотреть эти связи в явном виде.
Для этого используем [Graphviz](http://www.graphviz.org/) для графа и [Feh](https://wiki.archlinux.org/index.php/feh) для просмотра.
На Ubuntu они добавляются установкой пакетов `$ sudo apt install graphviz feh`

```bash
$ ./skeleton.sh svg
```

Связи указываются в явном виде и для этого каждая функция должна уметь обработать аргумент `--deps`.

Без зависимостей:
```bash
$ cat skeleton.sh
...
greetings() {
    [ "$1" == "--deps" ] && return 0 || true
...
```

С зависимостями:
```bash
$ cat skeleton.sh
...
make_my_day() {
    [ "$1" == "--deps" ] && _deps_and_exit "make" "my" "day" || true
...
```

#### Вспомогательные функции

Файл `skeleton.sh` содержит несколько вспомогательных функций, которые и добавляют нужную функциональность.
Предполагается, что работая с вашими командами эти вы оставите как есть:
 - `_help_and_exit` - описана выше;
 - `_deps_and_exit` - описана выше;
 - `print_functions` - показывает все имеющиеся функции, т.к. `usage` не показывает функции без строки описания и функции, чьё имя начинается с подчёркивания;
 - `print_hidden` - показывает только те функции, которые не показывает `usage`;
 - `usage` - описана выше;
 - `_make_dot_file` - используется в работе функции `svg`;
 - `svg` - описана выше.

Как и `usage`, `svg` игнорирует функции, чьё имя начинается с подчёркивания.

### skeleton.py

TODO

